package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"gopkg.in/yaml.v3"
)

type Config struct {
	Package  string         `yaml:"package"`
	Out      string         `yaml:"out"`
	Struct   string         `yaml:"struct"`
	Packages []PackageEntry `yaml:"packages"`
}

type PackageEntry struct {
	Path  string `yaml:"path"`
	Type  string `yaml:"type"`
	Name  string `yaml:"name"`
	Alias string `yaml:"alias,omitempty"`
}

const codeTemplate = `// Code generated by genout; DO NOT EDIT.
package {{.Package}}

import (
	"fmt"
	"slices"
	"sync"
{{- range .Packages }}
	{{ .Alias }} "{{ .Path }}"
{{- end }}
)

type Store struct {
	mu sync.RWMutex
{{- range .Packages }}
	{{ .Name }} []*{{ .Alias }}.{{ .Type }}
{{- end }}
}

func NewStore() *Store {
	return &Store{
{{- range .Packages }}
		{{ .Name }}: make([]*{{ .Alias }}.{{ .Type }}, 0),
{{- end }}
	}
}

{{- range .Packages }}
func (s *Store) {{ Pascal .Name }}Entries() []*{{ .Alias }}.{{ .Type }} {
	s.mu.RLock()
	defer s.mu.RUnlock()
	r := make([]*{{ .Alias }}.{{ .Type }}, len(s.{{ .Name }}))
	copy(r, s.{{ .Name }})
	return r
}
{{ end }}

{{- range .Packages }}
func (s *Store) add{{ Pascal .Name }}(c *{{ .Alias }}.{{ .Type }}) {
	s.mu.Lock()
	s.{{ .Name }} = append(s.{{ .Name }}, c)
	s.mu.Unlock()
}
{{ end }}

{{- range .Packages }}
func (s *Store) remove{{ Pascal .Name }}(c *{{ .Alias }}.{{ .Type }}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	i := slices.Index(s.{{ .Name }}, c)
	if i == -1 {
		return
	}
	s.{{ .Name }} = slices.Delete(s.{{ .Name }}, i, i+1)
}
{{ end }}

type {{.Struct}} struct {
	store *Store
{{- range .Packages }}
	{{ .Name }} *{{ .Alias }}.{{ .Type }}
{{- end }}
}

func New{{.Struct}}(store *Store) *{{.Struct}} {
	return &{{.Struct}}{
		store: store,
	}
}

{{/* --- Setters per component (WRAPPED IN RANGE) --- */}}
{{- range .Packages }}
func (o *{{$.Struct}}) Set{{ Pascal .Name }}(c *{{ .Alias }}.{{ .Type }}) error {
	if o.{{ .Name }} != nil {
		return fmt.Errorf("component {{ .Name }} already set")
	}
	o.{{ .Name }} = c
	if o.store != nil {
		o.store.add{{ Pascal .Name }}(c)
	}
	return nil
}
{{ end }}

{{/* --- Getters per component --- */}}
{{- range .Packages }}
func (o *{{$.Struct}}) {{ Pascal .Name }}() *{{ .Alias }}.{{ .Type }} { return o.{{ .Name }} }
{{- end }}

{{/* --- Removers per component (now clears field & store) --- */}}
{{- range .Packages }}
func (o *{{$.Struct}}) Remove{{ Pascal .Name }}() *{{ .Alias }}.{{ .Type }} {
	c := o.{{ .Name }}
	if c == nil {
		return nil
	}
	if o.store != nil {
		o.store.remove{{ Pascal .Name }}(c)
	}
	o.{{ .Name }} = nil
	return c
}
{{ end }}
`

func main() {
	cfgPath := flag.String("config", "components.yaml", "Path to YAML config")
	flag.Parse()

	b, err := os.ReadFile(*cfgPath)
	if err != nil {
		panic(fmt.Errorf("read config: %w", err))
	}

	var cfg Config
	if err := yaml.Unmarshal(b, &cfg); err != nil {
		panic(fmt.Errorf("parse YAML: %w", err))
	}

	if cfg.Package == "" {
		panic("missing 'package' in config")
	}
	if cfg.Struct == "" {
		cfg.Struct = "Out"
	}
	if cfg.Out == "" {
		cfg.Out = "components_gen.go"
	}
	if len(cfg.Packages) == 0 {
		panic("no packages defined in config")
	}

	// derive/import aliases (stable & unique)
	used := map[string]bool{}
	for i := range cfg.Packages {
		p := &cfg.Packages[i]
		if p.Path == "" || p.Type == "" || p.Name == "" {
			panic(fmt.Errorf("invalid package entry: %+v", *p))
		}
		if p.Alias == "" {
			base := sanitizeAlias(path.Base(p.Path))
			alias := base
			for n := 2; used[alias]; n++ {
				alias = fmt.Sprintf("%s%d", base, n)
			}
			p.Alias = alias
		}
		used[p.Alias] = true
	}

	// deterministic output
	sort.Slice(cfg.Packages, func(i, j int) bool {
		return cfg.Packages[i].Alias < cfg.Packages[j].Alias
	})

	// template with helper funcs
	funcs := template.FuncMap{
		"Pascal": toPascal,
	}
	tpl := template.Must(template.New("out").Funcs(funcs).Parse(codeTemplate))

	var buf bytes.Buffer
	if err := tpl.Execute(&buf, cfg); err != nil {
		panic(fmt.Errorf("template execution: %w", err))
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		_ = os.WriteFile(cfg.Out+".broken.go", buf.Bytes(), 0o644)
		panic(fmt.Errorf("format failed: %w", err))
	}

	if err := os.WriteFile(cfg.Out, formatted, 0o644); err != nil {
		panic(fmt.Errorf("write output: %w", err))
	}

	fmt.Println("âœ… Generated", cfg.Out)
}

func sanitizeAlias(s string) string {
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, " ", "_")
	if s == "" {
		s = "pkg"
	}
	return s
}

// toPascal uppercases the first letter; keeps existing camelCase beyond that.
func toPascal(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}
