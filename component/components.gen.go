// Code generated by genout; DO NOT EDIT.
package component

import (
	"fmt"
	"slices"
	"sync"

	agent "github.com/dwethmar/apostle/component/agent"
	kind "github.com/dwethmar/apostle/component/kind"
	movement "github.com/dwethmar/apostle/component/movement"
	path "github.com/dwethmar/apostle/component/path"
)

type Store struct {
	mu       sync.RWMutex
	agent    []*agent.Agent
	kind     []*kind.Kind
	movement []*movement.Movement
	path     []*path.Path
}

func NewStore() *Store {
	return &Store{
		agent:    make([]*agent.Agent, 0),
		kind:     make([]*kind.Kind, 0),
		movement: make([]*movement.Movement, 0),
		path:     make([]*path.Path, 0),
	}
}
func (s *Store) AgentEntries() []*agent.Agent {
	s.mu.RLock()
	defer s.mu.RUnlock()
	r := make([]*agent.Agent, len(s.agent))
	copy(r, s.agent)
	return r
}

func (s *Store) KindEntries() []*kind.Kind {
	s.mu.RLock()
	defer s.mu.RUnlock()
	r := make([]*kind.Kind, len(s.kind))
	copy(r, s.kind)
	return r
}

func (s *Store) MovementEntries() []*movement.Movement {
	s.mu.RLock()
	defer s.mu.RUnlock()
	r := make([]*movement.Movement, len(s.movement))
	copy(r, s.movement)
	return r
}

func (s *Store) PathEntries() []*path.Path {
	s.mu.RLock()
	defer s.mu.RUnlock()
	r := make([]*path.Path, len(s.path))
	copy(r, s.path)
	return r
}

func (s *Store) addAgent(c *agent.Agent) {
	s.mu.Lock()
	s.agent = append(s.agent, c)
	s.mu.Unlock()
}

func (s *Store) addKind(c *kind.Kind) {
	s.mu.Lock()
	s.kind = append(s.kind, c)
	s.mu.Unlock()
}

func (s *Store) addMovement(c *movement.Movement) {
	s.mu.Lock()
	s.movement = append(s.movement, c)
	s.mu.Unlock()
}

func (s *Store) addPath(c *path.Path) {
	s.mu.Lock()
	s.path = append(s.path, c)
	s.mu.Unlock()
}

func (s *Store) removeAgent(c *agent.Agent) {
	s.mu.Lock()
	defer s.mu.Unlock()
	i := slices.Index(s.agent, c)
	if i == -1 {
		return
	}
	s.agent = slices.Delete(s.agent, i, i+1)
}

func (s *Store) removeKind(c *kind.Kind) {
	s.mu.Lock()
	defer s.mu.Unlock()
	i := slices.Index(s.kind, c)
	if i == -1 {
		return
	}
	s.kind = slices.Delete(s.kind, i, i+1)
}

func (s *Store) removeMovement(c *movement.Movement) {
	s.mu.Lock()
	defer s.mu.Unlock()
	i := slices.Index(s.movement, c)
	if i == -1 {
		return
	}
	s.movement = slices.Delete(s.movement, i, i+1)
}

func (s *Store) removePath(c *path.Path) {
	s.mu.Lock()
	defer s.mu.Unlock()
	i := slices.Index(s.path, c)
	if i == -1 {
		return
	}
	s.path = slices.Delete(s.path, i, i+1)
}

type Components struct {
	store    *Store
	agent    *agent.Agent
	kind     *kind.Kind
	movement *movement.Movement
	path     *path.Path
}

func NewComponents(store *Store) *Components {
	return &Components{
		store: store,
	}
}

func (o *Components) SetAgent(c *agent.Agent) error {
	if o.agent != nil {
		return fmt.Errorf("component agent already set")
	}
	o.agent = c
	if o.store != nil {
		o.store.addAgent(c)
	}
	return nil
}

func (o *Components) SetKind(c *kind.Kind) error {
	if o.kind != nil {
		return fmt.Errorf("component kind already set")
	}
	o.kind = c
	if o.store != nil {
		o.store.addKind(c)
	}
	return nil
}

func (o *Components) SetMovement(c *movement.Movement) error {
	if o.movement != nil {
		return fmt.Errorf("component movement already set")
	}
	o.movement = c
	if o.store != nil {
		o.store.addMovement(c)
	}
	return nil
}

func (o *Components) SetPath(c *path.Path) error {
	if o.path != nil {
		return fmt.Errorf("component path already set")
	}
	o.path = c
	if o.store != nil {
		o.store.addPath(c)
	}
	return nil
}

func (o *Components) Agent() *agent.Agent          { return o.agent }
func (o *Components) Kind() *kind.Kind             { return o.kind }
func (o *Components) Movement() *movement.Movement { return o.movement }
func (o *Components) Path() *path.Path             { return o.path }

func (o *Components) RemoveAgent() *agent.Agent {
	c := o.agent
	if c == nil {
		return nil
	}
	if o.store != nil {
		o.store.removeAgent(c)
	}
	o.agent = nil
	return c
}

func (o *Components) RemoveKind() *kind.Kind {
	c := o.kind
	if c == nil {
		return nil
	}
	if o.store != nil {
		o.store.removeKind(c)
	}
	o.kind = nil
	return c
}

func (o *Components) RemoveMovement() *movement.Movement {
	c := o.movement
	if c == nil {
		return nil
	}
	if o.store != nil {
		o.store.removeMovement(c)
	}
	o.movement = nil
	return c
}

func (o *Components) RemovePath() *path.Path {
	c := o.path
	if c == nil {
		return nil
	}
	if o.store != nil {
		o.store.removePath(c)
	}
	o.path = nil
	return c
}
